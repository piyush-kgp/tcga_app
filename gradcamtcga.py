# -*- coding: utf-8 -*-
"""GradCamTCGA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mY6gm8eLleBXe35YcGMW-Hzc4f69dUB_
"""

# !nvidia-smi

# !tar xvzf brca.tar.gz

import torch.nn as nn
import torch.nn.functional as F
from torch.utils.tensorboard import SummaryWriter
from torchvision import datasets, models, transforms
import torch.optim as optim
from torch.utils.data import DataLoader, random_split, Dataset
import torch
import torchvision
from PIL import Image
import argparse
from sklearn.metrics import classification_report
import sklearn.metrics as metrics
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd
from PIL import Image, ImageFile
import json
import matplotlib.pyplot as plt
ImageFile.LOAD_TRUNCATED_IMAGES = True

def define_model(dropouts,hidden_layer_units,num_classes=2):
    # We optimize the number of layers, hidden untis and dropout ratio in each layer.
    layers = []
    model = models.resnet18(pretrained=True)
    in_features = model.fc.in_features
    for i in range(len(dropouts)):
        out_features = hidden_layer_units[i]
        layers.append(nn.Linear(in_features, out_features))
        layers.append(nn.ReLU())
        p = dropouts[i]
        layers.append(nn.Dropout(p))
        in_features = out_features
    layers.append(nn.Linear(in_features, num_classes))
    model.fc = nn.Sequential(*layers)
    return model

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print("DEVICE {}".format(device), flush=True)

model_checkpoint = "/Users/piyush/BRCA_best_model.pth"
ckpt = torch.load(model_checkpoint) if device=="cuda" else \
       torch.load(model_checkpoint, map_location=torch.device('cpu'))
ckpt = {k.replace("module.", ""): v for k, v in ckpt.items()}
model = define_model([0.4494231064473708],[87])
model.load_state_dict(ckpt)

model = model.to(device)

data_transform = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize([0.596, 0.436, 0.586], [0.2066, 0.240, 0.186])
    ])

# fp = "/content/TCGA-A1-A0SB-01A-01-BS1/TCGA-A1-A0SB-01A-01-BS1_X_1024_Y_3072.png"
# fp = "/content/TCGA-A1-A0SB-01A-01-BS1/TCGA-A1-A0SB-01A-01-BS1_X_1536_Y_4608.png"
fp = "/Users/piyush/TCGA-A1-A0SB-01A-01-BS1/TCGA-A1-A0SB-01A-01-BS1_X_15360_Y_3584.png"
img = Image.open(fp)
X = data_transform(img)
X = X.reshape(-1,3,224,224)
print(X.shape)
Y = "cancer"

model.eval()
modules = list(model.children())[:8]
model_gc = nn.Sequential(*modules)
for p in model_gc.parameters():
    p.requires_grad = False
activation = model_gc(X.to(device)).reshape((512,49))

sd = model.state_dict()
w1 = sd["fc.0.weight"]
w2 = sd["fc.3.weight"]

idx = 0 if Y=="Cancer" else 1
weight = (w1.T@w2.T)[:,idx].reshape(512)

cam = (weight@activation).reshape(7,7)
upsampler = nn.Upsample(scale_factor=32, mode='bicubic')
output = upsampler(cam.reshape(1,1,7,7)).reshape(224,224)

output = (output-output.min())/(output.max()-output.min())
output = output.cpu().numpy()
output = (255*output).astype(np.uint8)
Image.fromarray(output).save("out.jpg")

def apply_colormap_on_image(org_im, activation, colormap_name):
    import matplotlib.cm as mpl_color_map, copy
    """
        Apply heatmap on image
    Args:
        org_img (PIL img): Original image
        activation_map (numpy arr): Activation map (grayscale) 0-255
        colormap_name (str): Name of the colormap
    """
    # Get colormap
    color_map = mpl_color_map.get_cmap(colormap_name)
    no_trans_heatmap = color_map(activation)
    # Change alpha channel in colormap to make sure original image is displayed
    heatmap = copy.copy(no_trans_heatmap)
    heatmap[:, :, 3] = 0.4
    heatmap = Image.fromarray((heatmap*255).astype(np.uint8))
    no_trans_heatmap = Image.fromarray((no_trans_heatmap*255).astype(np.uint8))

    # Apply heatmap on iamge
    heatmap_on_image = Image.new("RGBA", org_im.size)
    heatmap_on_image = Image.alpha_composite(heatmap_on_image, org_im.convert('RGBA'))
    heatmap_on_image = Image.alpha_composite(heatmap_on_image, heatmap)
    return no_trans_heatmap, heatmap_on_image

cm = plt.get_cmap('jet')
colored_image = Image.fromarray((cm(output)*255).astype(np.uint8))
colored_image.save("test_direct.png")

# fp = "/content/TCGA-A1-A0SB-01A-01-BS1/TCGA-A1-A0SB-01A-01-BS1_X_1024_Y_3072.png"
import glob
for fp in glob.glob("/Users/piyush/TCGA-A1-A0SB-01A-01-BS1/*.png"):
  img = Image.open(fp)
  X = data_transform(img)
  X = X.reshape(-1,3,224,224)
  print("Pred:", model(X.to(device)).reshape(2,).argmax().item())
